

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>anisotropic_reflectivity &mdash; p-RSoXR 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../_static/thebelab.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> p-RSoXR
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../source/Installation.html">Software Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/DataCollection_home.html">Tutorial on Collecting Data:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/DataReduction_home.html">Reducing data to 1D profiles:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/DataModeling_home.html">Modeling/Fitting with PyPXR:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/references_home.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/API.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/legal.html">NIST Legal</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">p-RSoXR</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>anisotropic_reflectivity</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for anisotropic_reflectivity</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The refnx code is distributed under the following license:</span>

<span class="sd">Copyright (c) 2015 A. R. J. Nelson, ANSTO</span>

<span class="sd">Permission to use and redistribute the source code or binary forms of this</span>
<span class="sd">software and its documentation, with or without modification is hereby</span>
<span class="sd">granted provided that the above notice of copyright, these terms of use,</span>
<span class="sd">and the disclaimer of warranty below appear in the source code and</span>
<span class="sd">documentation, and that none of the names of above institutions or</span>
<span class="sd">authors appear in advertising or endorsement of works derived from this</span>
<span class="sd">software without specific prior written permission from all parties.</span>

<span class="sd">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="sd">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="sd">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="sd">THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="sd">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="sd">FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="sd">DEALINGS IN THIS SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">splrep</span><span class="p">,</span> <span class="n">splev</span>

<span class="kn">from</span> <span class="nn">refnx.analysis</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Parameters</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">possibly_create_parameter</span><span class="p">,</span>
                            <span class="n">Transform</span><span class="p">)</span>
<span class="c1"># from ani_reflect._biaxial_reflect import * ##TFerron Edits 05/20/2020 *Include model for anisotropic calculation</span>
<span class="kn">from</span> <span class="nn">_uniaxial_reflect</span> <span class="kn">import</span> <span class="o">*</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculates the specular reflectivity from a stratified series of layers</span>
<span class="sd">using polarized resonant soft X-ray reflectivity.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># some definitions for resolution smearing</span>
<span class="n">_FWHM</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="n">_INTLIMIT</span> <span class="o">=</span> <span class="mf">3.5</span>


<div class="viewcode-block" id="PXR_ReflectModel"><a class="viewcode-back" href="../source/PyPXR_API.html#anisotropic_reflectivity.PXR_ReflectModel">[docs]</a><span class="k">class</span> <span class="nc">PXR_ReflectModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    structure : anisotropic_structure.PXR_Structure object</span>
<span class="sd">        The interfacial structure.</span>
<span class="sd">    scale : float or refnx.analysis.Parameter, optional</span>
<span class="sd">        scale factor. All model values are multiplied by this value before</span>
<span class="sd">        the background is added. This is turned into a Parameter during the</span>
<span class="sd">        construction of this object.</span>
<span class="sd">    bkg : float or refnx.analysis.Parameter, optional</span>
<span class="sd">        Q-independent constant background added to all model values. This is</span>
<span class="sd">        turned into a Parameter during the construction of this object.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name of the Model</span>
<span class="sd">    dq : float or refnx.analysis.Parameter, optional</span>

<span class="sd">        - `dq == 0` then no resolution smearing is employed.</span>
<span class="sd">        - `dq` is a float or refnx.analysis.Parameter</span>
<span class="sd">           a constant dQ/Q resolution smearing is employed.  For 5% resolution</span>
<span class="sd">           smearing supply 5.This value is turned into a Parameter during the construction of this object.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `x_err` is supplied to the `model` method, dq becomes overriden. that</span>
<span class="sd">    overrides any setting given here. </span>
<span class="sd">    </span>
<span class="sd">    Adding q-smearing greatly reduces the current speed of the calculation.</span>
<span class="sd">    Data collected at ALS 11.0.1.2 over the carbon edge likely does not require any q-smearing.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dq</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;uni&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energy</span> <span class="o">=</span> <span class="n">energy</span>  <span class="c1"># [eV]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span> <span class="o">=</span> <span class="n">phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pol</span> <span class="o">=</span> <span class="n">pol</span>  <span class="c1"># Output polarization</span>

        <span class="c1"># all reflectometry models need a scale factor and background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">bkg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;bkg&#39;</span><span class="p">)</span>

        <span class="c1"># we can optimize the resolution (but this is always overridden by</span>
        <span class="c1"># x_err if supplied. There is therefore possibly no dependence on it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;dq - resolution&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the generative model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            q values for the calculation.</span>
<span class="sd">        p : refnx.analysis.Parameters, optional</span>
<span class="sd">            parameters required to calculate the model</span>
<span class="sd">        x_err : np.ndarray</span>
<span class="sd">            dq resolution smearing values for the dataset being considered.</span>
<span class="sd">        </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reflectivity : np.ndarray</span>
<span class="sd">            Calculated reflectivity</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        Note:</span>
<span class="sd">        -------</span>
<span class="sd">        Uses the assigned &#39;Pol&#39; to determine the output state of &#39;s-pol&#39;, &#39;p-pol&#39; or both</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="n">x_err</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;ReflectModel(</span><span class="si">{_structure!r}</span><span class="s2">, name=</span><span class="si">{name!r}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; scale=</span><span class="si">{_scale!r}</span><span class="s2">, bkg=</span><span class="si">{_bkg!r}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; dq=</span><span class="si">{_dq!r}</span><span class="s2">, threads=</span><span class="si">{threads}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; quad_order=</span><span class="si">{quad_order}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter`</span>

<span class="sd">            - `dq.value == 0`</span>
<span class="sd">               no resolution smearing is employed.</span>
<span class="sd">            - `dq.value &gt; 0`</span>
<span class="sd">               a constant dQ/Q resolution smearing is employed.  For 5%</span>
<span class="sd">               resolution smearing supply 5. However, if `x_err` is supplied to</span>
<span class="sd">               the `model` method, then that overrides any setting reported</span>
<span class="sd">               here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span>

    <span class="nd">@dq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - all model values are multiplied by</span>
<span class="sd">        this value before the background is added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - linear background added to all</span>
<span class="sd">        model values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span>

    <span class="nd">@bkg</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Photon energy to evaluate the resonant reflectivity.</span>
<span class="sd">        Automatically updates all PXR_MaterialSLD objects associated with self.structure.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            energy : float</span>
<span class="sd">                Photon energy of X-ray probe.  </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energy</span>

    <span class="nd">@energy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energy</span> <span class="o">=</span> <span class="n">energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Polarization to calculate the resonant reflectivity.</span>
<span class="sd">        </span>
<span class="sd">            -`pol == &#39;s&#39;`</span>
<span class="sd">            Calculation returns s-polarization only.</span>
<span class="sd">            -`pol == &#39;p&#39;`</span>
<span class="sd">            Calculation returns p-polarization only.</span>
<span class="sd">            -`pol == &#39;sp&#39; or &#39;ps&#39;`</span>
<span class="sd">            Calulation returns concatenate in order of input.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            pol : str</span>
<span class="sd">                Linear polarizations state of incident raw</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pol</span>

    <span class="nd">@pol</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pol</span> <span class="o">=</span> <span class="n">pol</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Azimuthal angle of incidence [deg]. Only used with a biaxial calculation.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            phi : float</span>
<span class="sd">                Azimuthal angle of incidence used in calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span>

    <span class="nd">@phi</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span> <span class="o">=</span> <span class="n">phi</span>

<div class="viewcode-block" id="PXR_ReflectModel.model"><a class="viewcode-back" href="../source/PyPXR_API.html#anisotropic_reflectivity.PXR_ReflectModel.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the reflectivity of this model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            q or E values for the calculation.</span>
<span class="sd">            specifiy self.qval to be any value to fit energy-space</span>
<span class="sd">        p : refnx.analysis.Parameters, optional</span>
<span class="sd">            parameters required to calculate the model</span>
<span class="sd">        x_err : np.ndarray</span>
<span class="sd">            dq resolution smearing values for the dataset being considered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reflectivity : np.ndarray</span>
<span class="sd">            Calculated reflectivity. Output is dependent on `self.pol`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fallback to what this object was constructed with</span>
            <span class="n">x_err</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">)</span>

        <span class="c1"># Multipol fitting is currently done through concatenating s- and p-pol together.</span>
        <span class="c1"># A temp x-data set is used to calculate the model based on the q-range</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;sp&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;ps&#39;</span><span class="p">:</span>
            <span class="n">concat_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>  <span class="c1"># Location where the q-range swaps for high s-pol to low p-pol</span>
            <span class="n">qvals_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">concat_loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Split inputs for later</span>
            <span class="n">qvals_2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">concat_loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Split inputs for later</span>
            <span class="n">num_q</span> <span class="o">=</span> <span class="n">concat_loc</span> <span class="o">+</span> <span class="mi">50</span>  <span class="c1"># 50 more points to make sure the interpolation works</span>
            <span class="n">qvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">num_q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qvals</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">refl</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">PXR_reflectivity</span><span class="p">(</span><span class="n">qvals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">slabs</span><span class="p">(),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span>
                                                   <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                   <span class="n">bkg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                   <span class="n">dq</span><span class="o">=</span><span class="n">x_err</span><span class="p">,</span>
                                                   <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span>
                                                   <span class="p">)</span>
        <span class="c1"># Return result based on desired polarization:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;sp&#39;</span><span class="p">:</span>
            <span class="n">spol_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">qvals_1</span><span class="p">,</span> <span class="n">qvals</span><span class="p">,</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ppol_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">qvals_2</span><span class="p">,</span> <span class="n">qvals</span><span class="p">,</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spol_model</span><span class="p">,</span> <span class="n">ppol_model</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;ps&#39;</span><span class="p">:</span>
            <span class="n">spol_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">qvals_2</span><span class="p">,</span> <span class="n">qvals</span><span class="p">,</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ppol_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">qvals_1</span><span class="p">,</span> <span class="n">qvals</span><span class="p">,</span> <span class="n">refl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ppol_model</span><span class="p">,</span> <span class="n">spol_model</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No polarizations were chosen for model&#39;</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PXR_ReflectModel.logp"><a class="viewcode-back" href="../source/PyPXR_API.html#anisotropic_reflectivity.PXR_ReflectModel.logp">[docs]</a>    <span class="k">def</span> <span class="nf">logp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Additional log-probability terms for the reflectivity model. Do not</span>
<span class="sd">        include log-probability terms for model parameters, these are</span>
<span class="sd">        automatically included elsewhere.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logp : float</span>
<span class="sd">            log-probability of structure.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">logp</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`PRSoXR.PXR_Structure` - object describing the interface of</span>
<span class="sd">        a reflectometry sample.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

    <span class="nd">@structure</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;instrument parameters&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">parameters</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameters` - parameters associated with this</span>
<span class="sd">        model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span></div>


<span class="k">def</span> <span class="nf">PXR_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">slabs</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dq</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;uni&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Full calculation for anisotropic reflectivity of a stratified medium</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : np.ndarray</span>
<span class="sd">        The qvalues required for the calculation.</span>
<span class="sd">        :math:`Q=\frac{4Pi}{\lambda}\sin(\Omega)`.</span>
<span class="sd">        Units = Angstrom**-1</span>
<span class="sd">    slabs : np.ndarray</span>
<span class="sd">        coefficients required for the calculation, has shape (2 + N, 4),</span>
<span class="sd">        where N is the number of layers</span>

<span class="sd">        - slabs[0, 0]</span>
<span class="sd">           ignored</span>
<span class="sd">        - slabs[N, 0]</span>
<span class="sd">           thickness of layer N</span>
<span class="sd">        - slabs[N+1, 0]</span>
<span class="sd">           ignored</span>

<span class="sd">        - slabs[0, 1]</span>
<span class="sd">           trace of real index tensor of fronting (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[N, 1]</span>
<span class="sd">           trace of real index tensor of layer N (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[-1, 1]</span>
<span class="sd">           trace of real index tensor of backing (/1e-6 Angstrom**-2)</span>

<span class="sd">        - slabs[0, 2]</span>
<span class="sd">           trace of imaginary index tensor of fronting (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[N, 2]</span>
<span class="sd">           trace of imaginary index tensor of layer N (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[-1, 2]</span>
<span class="sd">           trace of imaginary index tensor of backing (/1e-6 Angstrom**-2)</span>

<span class="sd">        - slabs[0, 3]</span>
<span class="sd">           ignored</span>
<span class="sd">        - slabs[N, 3]</span>
<span class="sd">           roughness between layer N-1/N</span>
<span class="sd">        - slabs[-1, 3]</span>
<span class="sd">           roughness between backing and layer N</span>
<span class="sd">        </span>
<span class="sd">    tensor : 3x3 numpy array</span>
<span class="sd">        The full dielectric tensor required for the anisotropic calculation.</span>
<span class="sd">        Each component (real and imaginary) is a fit parameter </span>
<span class="sd">        Has shape (2 + N, 3, 3)</span>
<span class="sd">        units - unitless</span>
<span class="sd">        </span>
<span class="sd">    energy : float</span>
<span class="sd">        Energy to calculate the reflectivity profile </span>
<span class="sd">        Used in calculating &#39;q&#39; and index of refraction for PXR_MaterialSLD objects</span>
<span class="sd">        </span>
<span class="sd">    phi : float</span>
<span class="sd">        Azimuthal angle of incidence for calculating k-vectors.</span>
<span class="sd">        This is only required if dealing with a biaxial tensor</span>
<span class="sd">        defaults to phi = 0 ~</span>
<span class="sd">        </span>
<span class="sd">    scale : float</span>
<span class="sd">        scale factor. All model values are multiplied by this value before</span>
<span class="sd">        the background is added</span>
<span class="sd">        </span>
<span class="sd">    bkg : float</span>
<span class="sd">        Q-independent constant background added to all model values.</span>
<span class="sd">        </span>
<span class="sd">    dq : float or np.ndarray, optional</span>
<span class="sd">        - `dq == 0`</span>
<span class="sd">           no resolution smearing is employed.</span>
<span class="sd">        - `dq` is a float</span>
<span class="sd">           a constant dQ/Q resolution smearing is employed.  For 5% resolution</span>
<span class="sd">           smearing supply 5.</span>

<span class="sd">   backend : str (&#39;uni&#39; or &#39;bi&#39;)</span>
<span class="sd">        Calculation symmetry to be applied. &#39;uni&#39; for a uniaxial approximation (~10x increase in speed).</span>
<span class="sd">        &#39;bi&#39; for full biaxial calculation.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; from refnx.reflect import reflectivity</span>
<span class="sd">    &gt;&gt;&gt; q = np.linspace(0.01, 0.5, 1000)</span>
<span class="sd">    &gt;&gt;&gt; slabs = np.array([[0, 2.07, 0, 0],</span>
<span class="sd">    ...                   [100, 3.47, 0, 3],</span>
<span class="sd">    ...                   [500, -0.5, 0.00001, 3],</span>
<span class="sd">    ...                   [0, 6.36, 0, 3]])</span>
<span class="sd">    &gt;&gt;&gt; print(reflectivity(q, slabs))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># constant dq/q smearing</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;uni&#39;</span><span class="p">:</span>
            <span class="n">refl</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">uniaxial_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">slabs</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refl</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">yeh_4x4_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">slabs</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">refl</span> <span class="o">+</span> <span class="n">bkg</span><span class="p">),</span> <span class="n">tran</span><span class="p">,</span> <span class="n">components</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
        <span class="n">dq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span>
        <span class="n">smear_refl</span><span class="p">,</span> <span class="n">smear_tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">_smeared_PXR_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span>
                                                                        <span class="n">slabs</span><span class="p">,</span>
                                                                        <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                                                                        <span class="n">dq</span><span class="p">,</span>
                                                                        <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">smear_tefl</span> <span class="o">+</span> <span class="n">bkg</span><span class="p">),</span> <span class="n">smear_tran</span><span class="p">,</span> <span class="n">components</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_smeared_PXR_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;uni&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast resolution smearing for constant dQ/Q.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q: np.ndarray</span>
<span class="sd">        Q values to evaluate the reflectivity at</span>
<span class="sd">    w: np.ndarray</span>
<span class="sd">        Parameters for the reflectivity model</span>
<span class="sd">    resolution: float</span>
<span class="sd">        Percentage dq/q resolution. dq specified as FWHM of a resolution</span>
<span class="sd">        kernel.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflectivity: np.ndarray</span>
<span class="sd">        The resolution smeared reflectivity</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">resolution</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;uni&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">uniaxial_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">yeh_4x4_reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

    <span class="n">resolution</span> <span class="o">/=</span> <span class="mi">100</span>
    <span class="n">gaussnum</span> <span class="o">=</span> <span class="mi">51</span>
    <span class="n">gaussgpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">gaussnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">s</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">s</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span>

    <span class="n">lowq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">highq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lowq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lowq</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highq</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span><span class="p">))</span>
    <span class="n">interpnum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">finish</span><span class="p">))</span> <span class="o">/</span>
                                <span class="p">(</span><span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span> <span class="o">/</span> <span class="n">gaussgpoint</span><span class="p">)))</span>
    <span class="n">xtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">interpnum</span><span class="p">))</span>
    <span class="n">xlin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">)</span>

    <span class="c1"># resolution smear over [-4 sigma, 4 sigma]</span>
    <span class="n">gauss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">,</span> <span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">gaussnum</span><span class="p">)</span>
    <span class="n">gauss_y</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="n">gauss_x</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;uni&#39;</span><span class="p">:</span>
        <span class="n">refl</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">uniaxial_reflectivity</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">refl</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="n">yeh_4x4_reflectivity</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
    <span class="c1"># Refl, Tran = yeh_4x4_reflectivity(xlin, w, tensor, Energy, phi, threads=threads,save_components=None)</span>
    <span class="c1"># Convolve each solution independently</span>
    <span class="n">smeared_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">refl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gauss_y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gauss_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">smeared_pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">refl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">gauss_y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gauss_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">smeared_sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">refl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">gauss_y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gauss_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">smeared_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">refl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gauss_y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gauss_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># smeared_rvals *= gauss_x[1] - gauss_x[0]</span>

    <span class="c1"># interpolator = InterpolatedUnivariateSpline(xlin, smeared_rvals)</span>
    <span class="c1">#</span>
    <span class="c1"># smeared_output = interpolator(q)</span>
    <span class="c1"># Re-interpolate and organize the results wave following spline interpolation</span>
    <span class="n">tck_ss</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">smeared_ss</span><span class="p">)</span>
    <span class="n">smeared_output_ss</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tck_ss</span><span class="p">)</span>

    <span class="n">tck_sp</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">smeared_sp</span><span class="p">)</span>
    <span class="n">smeared_output_sp</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tck_sp</span><span class="p">)</span>

    <span class="n">tck_ps</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">smeared_ps</span><span class="p">)</span>
    <span class="n">smeared_output_ps</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tck_ps</span><span class="p">)</span>

    <span class="n">tck_pp</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">smeared_pp</span><span class="p">)</span>
    <span class="n">smeared_output_pp</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tck_pp</span><span class="p">)</span>

    <span class="c1"># Organize the output wave with the appropriate outputs</span>
    <span class="n">smeared_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">smeared_output_ss</span><span class="p">,</span> <span class="n">smeared_output_sp</span><span class="p">],</span> <span class="p">[</span><span class="n">smeared_output_ps</span><span class="p">,</span> <span class="n">smeared_output_pp</span><span class="p">]]),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">smeared_output</span><span class="p">,</span> <span class="n">tran</span><span class="p">,</span> <span class="n">components</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright : Official Contribution of the US Government.  Not subject to copyright in the United States..

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>